<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Hands-Free Solfège Ear Trainer (Kodály)</title>
<style>
  :root{--bg:#0e0f12;--panel:#171a20;--text:#eaeef5;--muted:#9aa4b2}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
  header{padding:16px 20px;border-bottom:1px solid #1f222b;background:linear-gradient(180deg,#12141a,#0e0f12 60%)}
  h1{margin:0 0 4px;font-size:18px}.sub{margin:0;color:var(--muted);font-size:13px}
  .wrap{max-width:1000px;margin:0 auto;padding:16px;display:grid;gap:16px}
  .panel{background:var(--panel);border:1px solid #252935;border-radius:12px;padding:12px}
  .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
  fieldset{border:1px solid #2a3040;border-radius:10px;padding:10px 12px}
  legend{color:var(--muted);font-size:12px;padding:0 6px}
  label{font-size:13px}
  select,input[type=number]{background:#0f1116;color:#eaeef5;border:1px solid #2a3040;border-radius:8px;padding:6px 8px}
  button{background:#1b2430;color:#eaeef5;border:1px solid #2a3040;border-radius:10px;padding:10px 14px;cursor:pointer;font-weight:600}
  button.running{background:#1f3b2a;border-color:#2d614a;color:#c8ffd7}
  .hint{color:var(--muted);font-size:12px}

  /* Keyboard */
  .kbd-wrap{display:flex;justify-content:center}
  .keyboard{position:relative;height:178px}
  .white,.black{position:absolute;border:1px solid #333;border-bottom-left-radius:4px;border-bottom-right-radius:4px}
  .white{background:#fff}
  .black{background:#111;border-color:#222;z-index:2}
  .white.lit{box-shadow:inset 0 0 0 2px #0077ff,0 0 12px #0077ff;background:#f2fbff}
  .black.lit{box-shadow:inset 0 0 0 2px #66ccff,0 0 12px #66ccff;background:#1f3b4d}
  .note-tag{position:absolute;left:0;right:0;text-align:center;font-size:11px;color:#333;pointer-events:none}
  .solf-tag{position:absolute;left:0;right:0;text-align:center;font-size:12px;font-weight:700;color:#26323f;pointer-events:none}
  .variant-tag{position:absolute;left:0;right:0;text-align:center;font-size:10px;color:#5e6a77;pointer-events:none}
  .white .note-tag{bottom:42px}.white .solf-tag{bottom:22px}.white .variant-tag{bottom:6px}
  .black .note-tag{bottom:36px;color:#ccd;font-weight:600}.black .solf-tag{bottom:18px;color:#e2eef9}
  .black .variant-tag{bottom:6px;color:#c7d6e6}
  .white.lit .note-tag{color:#014}.black.lit .note-tag{color:#e8f7ff}
  .white.lit .solf-tag{color:#013}.black.lit .solf-tag{color:#e8f7ff}
  .white.lit .variant-tag{color:#012}.black.lit .variant-tag{color:#e8f7ff}

  /* Big reveal syllable overlay */
  .syllable-pop{
    position:fixed; left:50%; top:14%; transform:translateX(-50%);
    font-size:48px; font-weight:800; letter-spacing:1px;
    color:#eaf6ff; text-shadow:0 2px 14px rgba(0,0,0,0.55);
    pointer-events:none; opacity:0; transition:opacity .06s ease;
    background:rgba(20,28,40,0.55); padding:.25rem .75rem; border-radius:12px; border:1px solid #2a3b50;
    z-index:9999;
  }
  .syllable-pop.show{ opacity:1; }

  /* Audio unlock overlay */
  #unlockAudio{
    position:fixed; inset:0; z-index:99999; background:#0e0f12; display:flex;
    align-items:center; justify-content:center; border:0; color:#eaeef5;
    font-size:20px; font-weight:700; letter-spacing:.3px
  }

  @media (max-width:520px){
    button, select, input[type=number]{ padding:12px 14px; font-size:16px }
    .panel{ padding:10px }
  }
</style>
</head>
<body>
<header>
  <h1>Hands-Free Solfège Ear Trainer</h1>
  <p class="sub">C-major cadence • random targets (1–4) • same-octave reveal (F♯↑ / F↓) • Kodály syllables (black keys show sharp/flat)</p>
</header>

<!-- Audio unlock (iOS Safari safe) -->
<button id="unlockAudio">Tap to enable sound</button>

<div class="wrap">
  <div class="panel">
    <div class="row">
      <fieldset>
        <legend>Pitch-classes (targets)</legend>
        <div class="row" id="pcRow"></div>
        <div class="hint">Tick which of the 12 notes may be chosen as targets.</div>
      </fieldset>

      <fieldset>
        <legend>Range for targets</legend>
        <div class="row">
          <label>Lowest</label><select id="lowSel"></select>
          <label>Highest</label><select id="highSel"></select>
        </div>
        <div class="hint">Only the target(s) are range-filtered; reveal stays in each target’s octave.</div>
      </fieldset>

      <fieldset>
        <legend>Flow</legend>
        <div class="row">
          <label>Cadence every</label><input id="cadEvery" type="number" min="1" value="1" style="width:72px"> rounds
          <label>BPM (cadence)</label><input id="bpm" type="number" min="30" max="200" value="88" style="width:80px">
          <label>Targets at once</label>
          <select id="stackCount"><option>1</option><option>2</option><option>3</option><option>4</option></select>
        </div>
        <div class="row">
          <label>Pre-note silence</label><input id="preSil" type="number" min="0" step="0.1" value="0.5" style="width:80px"> s
          <label>Note→reveal wait</label><input id="revealWait" type="number" min="0" step="0.1" value="1.0" style="width:80px"> s
          <label>Between rounds</label><input id="between" type="number" min="0" step="0.1" value="1.0" style="width:80px"> s
        </div>
      </fieldset>

      <fieldset>
        <legend>Timing</legend>
        <div class="row">
          <label>Note duration (target)</label><input id="noteLen" type="number" min="0.05" step="0.05" value="0.8" style="width:90px"> s
          <label>Reveal tempo</label><input id="revealBpm" type="number" min="30" max="360" value="80" style="width:90px"> BPM
        </div>
        <div class="hint">Reveal notes auto-shortened (~80% of step) so they never overlap.</div>
      </fieldset>

      <fieldset>
        <legend>Reveal Mode</legend>

        <div class="row">
          <label>How to reveal</label>
          <select id="revealMode" style="width:180px">
            <option value="scale">Play scale (current)</option>
            <option value="speak">Speak note name</option>
          </select>
          <label>
            <input id="speakRef" type="checkbox" checked>
            Mix quiet reference tone
          </label>
        </div>

        <div class="row">
          <label>Spoken content</label>
          <select id="speechContent" style="width:180px">
            <option value="note">Note names (C, C sharp…)</option>
            <option value="solfege">Solfège (Do, Di/Ra…)</option>
          </select>
          <label>
            <input id="speakOctave" type="checkbox" checked>
            Include octave number
          </label>
        </div>
      </fieldset>


    </div>
  </div>

  <div class="panel">
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn">Stop</button>
      <span id="status" class="hint">Stopped.</span>
    </div>
  </div>

  <div class="panel kbd-wrap">
    <div id="keyboard" class="keyboard" aria-label="Single-octave keyboard"></div>
  </div>
</div>

<div id="syllPop" class="syllable-pop"></div>

<script>
(() => {
  // ===== State =====
  let running=false, round=0, audioUnlocked=false;
  let wakeLock=null, wakeLockEnabled=true; // keep screen on while running

  // ===== Music helpers =====
  const A4=440, A4_MIDI=69;
  const noteNames=["C","C♯","D","D♯","E","F","F♯","G","G♯","A","A♯","B"];
  const diatonicPCs=new Set([0,2,4,5,7,9,11]);
  const midiToFreq=m=>A4*Math.pow(2,(m-A4_MIDI)/12);
  const midiToName=m=>`${noteNames[m%12]}${Math.floor(m/12)-1}`;
  const nearestLocalCDown=m=>Math.floor(m/12)*12;
  const isAccidental=m=>!diatonicPCs.has(m%12);

  // Kodály syllables
  const DIA = {0:"DO",2:"RE",4:"MI",5:"FA",7:"SOL",9:"LA",11:"TI"};
  const SHP = {1:"DI",3:"RI",6:"FI",8:"SI",10:"LI"};
  const FLT = {1:"RA",3:"ME",6:"SE",8:"LE",10:"TE"};
  function syllableForPC(pc, dir){ if(DIA[pc]) return DIA[pc]; return dir==='down'?FLT[pc]:SHP[pc]; }

  // ===== TTS (Text-to-Speech) helpers =====
  const tts = {
    ready: false,
    voices: [],
    init(){
      if (this.ready) return;
      const load = () => {
        this.voices = speechSynthesis.getVoices() || [];
        this.ready = true;
      };
      load();
      // Some browsers populate voices asynchronously
      window.speechSynthesis.onvoiceschanged = load;
    },
    pickVoice(){
      // Prefer an English voice if available; fall back to default
      const v = this.voices.find(v=>/en(-|_|$)/i.test(v.lang)) || this.voices[0];
      return v || null;
    }
  };

  // Speakable names: prefer sharps when revealing 'up', flats when 'down'
  const SHARP_TEXT = {1:'C sharp',3:'D sharp',6:'F sharp',8:'G sharp',10:'A sharp'};
  const FLAT_TEXT  = {1:'D flat', 3:'E flat', 6:'G flat', 8:'A flat', 10:'B flat'};
  function pcSpeakable(pc, dir){
    const base = {0:'C',2:'D',4:'E',5:'F',7:'G',9:'A',11:'B'};
    if (base[pc]) return base[pc];
    return (dir==='down' ? FLAT_TEXT[pc] : SHARP_TEXT[pc]) || noteNames[pc];
  }

  // Say "C sharp four" etc. Optionally include the octave.
  function speakNoteName(midi, dir, {includeOctave=true, rate=1.0, volume=1.0}={}){
    try{
      tts.init();
      const pc = midi % 12;
      const oct = Math.floor(midi/12) - 1;
      const text = includeOctave ? `${pcSpeakable(pc, dir)} ${oct}` : pcSpeakable(pc, dir);
      const u = new SpeechSynthesisUtterance(text);
      const voice = tts.pickVoice();
      if (voice) u.voice = voice;
      u.rate = Math.max(0.5, Math.min(1.4, rate));
      u.volume = Math.max(0, Math.min(1, volume));
      speechSynthesis.cancel(); // stop any prior utterance
      speechSynthesis.speak(u);
    }catch(e){ console.warn('TTS error', e); }
  }

  // Play a soft reference tone underneath speech to “pin” the exact pitch.
  function speakWithReference(midi, start, dur, dir){
    // Start speech immediately (tts has its own timing)
    speakNoteName(midi, dir, {includeOctave:true, rate:1.0, volume:1.0});
    // Quiet helper tone at precise frequency
    const ctx = audio.ctx;
    const f = midiToFreq(midi);
    const osc = ctx.createOscillator();
    const g  = ctx.createGain();
    osc.type='sine'; osc.frequency.value=f;
    g.gain.setValueAtTime(0.0001, start);
    g.gain.linearRampToValueAtTime(0.16, start + 0.03); // fade in
    g.gain.setValueAtTime(0.16, start + Math.max(0, dur - 0.12));
    g.gain.linearRampToValueAtTime(0.0001, start + dur); // fade out
    osc.connect(g); g.connect(audio.master);
    osc.start(start);
    osc.stop(start + dur + 0.05);
  }

  function solfegePhonetic(pc, dir){
    // Diatonic
    const DIA = {0:"doh", 2:"ray", 4:"mee", 5:"fah", 7:"sohl", 9:"lah", 11:"tee"};
    // Sharps
    const SHP = {1:"dee", 3:"ree", 6:"fee", 8:"see", 10:"lee"};
    // Flats
    const FLT = {1:"rah", 3:"may", 6:"say", 8:"lay", 10:"tay"};

    if (DIA[pc]) return DIA[pc];
    return (dir === 'down' ? FLT[pc] : SHP[pc]);
  }

    // Build the spoken label based on mode: "note" or "solfege"
  function buildSpokenLabel(midi, dir, {includeOctave=true, mode='note'}={}){
    const pc  = midi % 12;
    const oct = Math.floor(midi/12) - 1;

    if (mode === 'solfege'){
      const syl = solfegePhonetic(pc, dir);
      return includeOctave ? `${syl} ${oct}` : syl;
    }

    // (Note-name logic stays the same)
    const name = pcSpeakable(pc, dir);
    return includeOctave ? `${name} ${oct}` : name;
  }

  // Async speak for any label
  function speakLabelAsync(midi, dir, {includeOctave=true, rate=1.0, volume=1.0, mode='note'}={}){
    return new Promise(resolve => {
      try{
        tts.init();
        const text = buildSpokenLabel(midi, dir, {includeOctave, mode});
        const u = new SpeechSynthesisUtterance(text);
        const voice = tts.pickVoice();
        if (voice) u.voice = voice;
        u.rate = Math.max(0.5, Math.min(1.4, rate));
        u.volume = Math.max(0, Math.min(1, volume));

        let settled = false;
        const settle = () => { if (!settled){ settled = true; resolve(); } };
        u.onend = settle; u.onerror = settle;

        speechSynthesis.cancel();
        speechSynthesis.speak(u);

        const approxMs = Math.max(600, text.length * 60 / u.rate);
        setTimeout(settle, approxMs + 200);
      }catch(e){ console.warn('TTS error', e); resolve(); }
    });
  }


  // ===== Audio =====
  const audio={ctx:null, master:null,
    init(){ if(!this.ctx){ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); this.master=this.ctx.createGain(); this.master.gain.value=0.28; this.master.connect(this.ctx.destination);} },
    t(){ return this.ctx?this.ctx.currentTime:0; }
  };

  // ===== Wake Lock =====
  async function requestWakeLock(){
    try{
      if('wakeLock' in navigator){
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', ()=>console.log('Wake Lock released'));
        console.log('Wake Lock active');
      }
    }catch(err){ console.warn('Wake Lock error', err); }
  }
  function releaseWakeLock(){ if(wakeLock){ wakeLock.release().catch(()=>{}); wakeLock=null; } }
  document.addEventListener('visibilitychange', ()=>{
    if(document.visibilityState==='visible'){
      if(wakeLockEnabled) requestWakeLock();
      if(audio.ctx && audio.ctx.state!=='running'){ audio.ctx.resume().catch(()=>{}); }
    }else{
      releaseWakeLock();
    }
  });

  // ===== UI refs =====
  const pcRow=document.getElementById('pcRow');
  const lowSel=document.getElementById('lowSel');
  const highSel=document.getElementById('highSel');
  const cadEvery=document.getElementById('cadEvery');
  const bpmEl=document.getElementById('bpm');
  const preSil=document.getElementById('preSil');
  const revealWait=document.getElementById('revealWait');
  const between=document.getElementById('between');
  const noteLen=document.getElementById('noteLen');
  const revealBpm=document.getElementById('revealBpm');
  const stackCountEl=document.getElementById('stackCount');
  const startBtn=document.getElementById('startBtn');
  const stopBtn=document.getElementById('stopBtn');
  const statusEl=document.getElementById('status');
  const kbdEl=document.getElementById('keyboard');
  const revealModeEl = document.getElementById('revealMode');
  const speakRefEl   = document.getElementById('speakRef');
  const speechContentEl = document.getElementById('speechContent');
  const speakOctaveEl   = document.getElementById('speakOctave');



  // ===== Pitch-class toggles =====
  const pcChecks=[];
  for(let pc=0;pc<12;pc++){
    const wrap=document.createElement('label');
    const cb=document.createElement('input');
    cb.type='checkbox'; cb.value=pc; cb.checked=true;
    pcChecks.push(cb); wrap.appendChild(cb); wrap.appendChild(document.createTextNode(' '+noteNames[pc]));
    pcRow.appendChild(wrap);
  }
  pcChecks.forEach(cb => cb.checked = diatonicPCs.has(+cb.value)); // C major defaults

  // ===== Range options =====
  const LOW=36,HIGH=96;
  function addOpts(sel,from,to,def){ for(let m=from;m<=to;m++){const o=document.createElement('option');o.value=m;o.textContent=midiToName(m);sel.appendChild(o);} sel.value=def; }
  addOpts(lowSel,LOW,HIGH,48); addOpts(highSel,LOW,HIGH,84);
  [lowSel,highSel].forEach(el=>el.addEventListener('change',()=>{ if(+lowSel.value>+highSel.value) highSel.value=lowSel.value; if(+highSel.value<+lowSel.value) lowSel.value=highSel.value; }));

  // ===== Responsive keyboard sizing =====
  let WHITE_W, WHITE_H, BLACK_W, BLACK_H;
  const whitePC=[0,2,4,5,7,9,11];
  const blackAfter={0:1,2:3,5:6,7:8,9:10};
  const pcToKeyEl=new Map();

  function sizeKeyboard(){
    const maxPx=Math.min(window.innerWidth-32, 560);
    const perWhite=Math.max(28, Math.floor(maxPx/7));
    WHITE_W=perWhite; WHITE_H=Math.round(WHITE_W*4.4);
    BLACK_W=Math.round(WHITE_W*0.66); BLACK_H=Math.round(WHITE_H*0.68);
    kbdEl.style.height=(WHITE_H+20)+'px';
    kbdEl.style.width=(WHITE_W*7 + 2)+'px';
  }
  function enharmonicFlatName(pc){ const map={1:'D♭',3:'E♭',6:'G♭',8:'A♭',10:'B♭'}; return map[pc]||''; }

  function drawSingleOctave(){
    kbdEl.innerHTML=''; pcToKeyEl.clear();
    // Whites
    whitePC.forEach((pc,i)=>{
      const x=i*WHITE_W;
      const w=document.createElement('div'); w.className='white';
      Object.assign(w.style,{width:WHITE_W+'px',height:WHITE_H+'px',left:x+'px',top:'0px'});
      const tag=document.createElement('div'); tag.className='note-tag'; tag.textContent=noteNames[pc];
      const solf=document.createElement('div'); solf.className='solf-tag'; solf.textContent=DIA[pc];
      const varTag=document.createElement('div'); varTag.className='variant-tag'; varTag.textContent='';
      w.appendChild(tag); w.appendChild(solf); w.appendChild(varTag);
      kbdEl.appendChild(w); pcToKeyEl.set(pc,w);
    });
    // Blacks
    whitePC.forEach((pc,i)=>{
      if(!(pc in blackAfter)) return;
      const bpc=blackAfter[pc];
      const left=i*WHITE_W + (WHITE_W - BLACK_W/2);
      const b=document.createElement('div'); b.className='black';
      Object.assign(b.style,{width:BLACK_W+'px',height:BLACK_H+'px',left:left+'px',top:'0px'});
      const tag=document.createElement('div'); tag.className='note-tag'; tag.textContent=noteNames[bpc].replace('♯','#')+' / '+enharmonicFlatName(bpc);
      const solf=document.createElement('div'); solf.className='solf-tag'; solf.textContent='';
      const varTag=document.createElement('div'); varTag.className='variant-tag'; varTag.textContent=`${SHP[bpc]} / ${FLT[bpc]}`;
      b.appendChild(tag); b.appendChild(solf); b.appendChild(varTag);
      kbdEl.appendChild(b); pcToKeyEl.set(bpc,b);
    });
  }
  window.addEventListener('resize',()=>{ sizeKeyboard(); drawSingleOctave(); },{passive:true});
  sizeKeyboard(); drawSingleOctave();

  // ===== Popup syllables =====
  const syllPop=document.getElementById('syllPop');
  function showSyllableAt(time,dur,text){
    const msUntil=Math.max(0,(time-audio.t())*1000), msDur=Math.max(150,dur*1000);
    setTimeout(()=>{syllPop.textContent=text; syllPop.classList.add('show'); setTimeout(()=>syllPop.classList.remove('show'),msDur);},msUntil);
  }

  // ===== Scheduling =====
  function scheduleTone(midi, start, dur, vel=0.95, popupDir=null){
    const ctx = audio.ctx;
    const f = midiToFreq(midi);

    // --- Build a tiny additive synth: fundamental + gentle 2nd/3rd partials.
    // Also add an octave-up helper for very low notes to aid pitch clarity.
    const bus = ctx.createGain();
    const A=0.01, D=0.06, S=0.75, R=Math.min(0.12, Math.max(0.06, dur*0.33));
    const peak=vel, sustain=vel*S;

    // Shared envelope on the mix bus (pre-master)
    bus.gain.setValueAtTime(0.0001, start);
    bus.gain.linearRampToValueAtTime(peak, start + A);
    bus.gain.linearRampToValueAtTime(sustain, start + A + D);
    bus.gain.setValueAtTime(sustain, start + Math.max(0, dur - R));
    bus.gain.linearRampToValueAtTime(0.0001, start + dur);

    // Fundamental (sine to stay clean)
    const o1 = ctx.createOscillator();
    o1.type = 'sine'; o1.frequency.value = f;
    o1.connect(bus);

    // Subtle 2nd and 3rd partials to add pitch cues without sounding buzzy
    const o2 = ctx.createOscillator(), g2 = ctx.createGain();
    o2.type='sine'; o2.frequency.value = f*2; g2.gain.value = 0.18; // ~ -15 dB
    o2.connect(g2); g2.connect(bus);

    const o3 = ctx.createOscillator(), g3 = ctx.createGain();
    o3.type='sine'; o3.frequency.value = f*3; g3.gain.value = 0.10; // ~ -20 dB
    o3.connect(g3); g3.connect(bus);

    // Octave-up reinforcement for bass notes (only if really low)
    let oUp, gUp;
    if (f < 130) { // roughly below C3
      oUp = ctx.createOscillator(); gUp = ctx.createGain();
      oUp.type='sine'; oUp.frequency.value = f*2; gUp.gain.value = 0.22; // gentle helper
      oUp.connect(gUp); gUp.connect(bus);
    }

    // Route to master
    bus.connect(audio.master);

    // Start/stop
    [o1,o2,o3].forEach(o => o.start(start));
    if (oUp) oUp.start(start);

    const stopAt = start + dur + 0.05;
    [o1,o2,o3].forEach(o => o.stop(stopAt));
    if (oUp) oUp.stop(stopAt);

    // Visuals + optional popup
    lightPC(midi%12, start, dur);
    if (popupDir!==undefined && popupDir!==null) {
      showSyllableAt(start, dur, syllableForPC(midi%12, popupDir));
    }
  }

  
  function scheduleChord(midis,start,dur,vel=0.95){
    midis.forEach(m=>scheduleTone(m,start,dur,vel,null)); // no popup for chord target
  }
  function lightPC(pc,start,dur){
    const el=pcToKeyEl.get(pc); if(!el) return;
    const msUntil=Math.max(0,(start-audio.t())*1000), msDur=dur*1000;
    setTimeout(()=>{el.classList.add('lit'); setTimeout(()=>el.classList.remove('lit'),msDur);},msUntil);
  }
  function sleepSec(s){ return new Promise(r=>setTimeout(r,s*1000)); }
  function quarterSec(){ return 60/Math.max(30,+bpmEl.value); }
  function revealStepSec(){ return 60/Math.max(30,+revealBpm.value); }

  // ===== Cadence / targets / reveal =====
  async function playCadence(){
    const q=quarterSec(), dur=q*0.9, g=0.9, t=audio.t()+0.02;
    const I=[60,64,67], IV=[65,69,72], V=[67,71,74];
    scheduleChord(I,t,dur,g); scheduleChord(IV,t+q,dur,g); scheduleChord(V,t+2*q,dur,g); scheduleChord(I,t+3*q,dur*1.15,g);
    await sleepSec(4*q+0.05);
  }

  function pickPool(){
    const l=+lowSel.value, h=+highSel.value;
    const allowed=new Set(pcChecks.filter(cb=>cb.checked).map(cb=>+cb.value));
    const pool=[]; for(let m=l;m<=h;m++){ if(allowed.has(m%12)) pool.push(m); }
    return pool;
  }
  function pickRandomTargets(k){
    const pool=pickPool(); if(!pool.length) return [];
    const chosen=[];
    while(chosen.length<k && pool.length){
      const idx=Math.floor(Math.random()*pool.length);
      chosen.push(pool[idx]);
      pool.splice(idx,1);
    }
    return chosen.sort((a,b)=>a-b);
  }

  async function playTargets(midis){
    const len=parseFloat(noteLen.value);
    scheduleChord(midis, audio.t()+0.02, len, 1.0);
    await sleepSec(len*0.9);
  }

  function buildReveal_Fsplit(midi){
    const localC=nearestLocalCDown(midi), topC=localC+12, pc=midi%12, goUp=(pc>=6);
    const seq=[midi];
    if(goUp){
      let cur=midi; if(isAccidental(cur) && cur+1<=topC){ cur+=1; seq.push(cur); }
      const asc=[7,9,11,12].map(s=>localC+s); for(const n of asc){ if(n>cur && n<=topC) seq.push(n); }
      return {seq, dir:'up'};
    }else{
      let cur=midi; if(isAccidental(cur) && cur-1>=localC){ cur-=1; seq.push(cur); }
      const desc=[5,4,2,0].map(s=>localC+s); for(const n of desc){ if(n<cur && n>=localC) seq.push(n); }
      return {seq, dir:'down'};
    }
  }
  async function revealOne(midi){
    const step=revealStepSec(), dur=Math.max(0.05, step*0.8);
    const {seq, dir}=buildReveal_Fsplit(midi);
    for(const m of seq){
      scheduleTone(m, audio.t()+0.02, dur, 0.95, dir);
      await sleepSec(step);
    }
  }
  
  async function revealAllSequential(midis){
    const mode = (revealModeEl && revealModeEl.value) || 'scale';
    const ordered = midis.slice().sort((a,b)=>a-b);

    if (mode === 'speak'){
      for (const m of ordered){
        await revealOneSpeak(m);
        await sleepSec(0.1);
      }
    } else {
      for (const m of ordered){
        await revealOne(m);
        await sleepSec(0.1);
      }
    }
  }

  async function revealOneSpeak(midi){
    const step    = revealStepSec();
    const toneDur = Math.max(0.4, step * 0.8);
    const { dir } = buildReveal_Fsplit(midi);

    const mode = (speechContentEl && speechContentEl.value) || 'note';
    const includeOctave = !!(speakOctaveEl && speakOctaveEl.checked);

    // 1) Speak first (await)
    await speakLabelAsync(midi, dir, { includeOctave, rate:1.0, volume:1.0, mode });

    // Brief gap
    await sleepSec(0.08);

    // 2) Then play the pitch once
    const t = audio.t() + 0.02;
    lightPC(midi % 12, t, toneDur);
    scheduleTone(midi, t, toneDur, 0.95, null);

    await sleepSec(toneDur + 0.05);
  }



  function speakNoteNameAsync(midi, dir, {includeOctave=true, rate=1.0, volume=1.0}={}){
    return new Promise(resolve => {
      try{
        tts.init();
        const pc = midi % 12;
        const oct = Math.floor(midi/12) - 1;
        const text = includeOctave ? `${pcSpeakable(pc, dir)} ${oct}` : pcSpeakable(pc, dir);
        const u = new SpeechSynthesisUtterance(text);
        const voice = tts.pickVoice();
        if (voice) u.voice = voice;
        u.rate = Math.max(0.5, Math.min(1.4, rate));
        u.volume = Math.max(0, Math.min(1, volume));

        // Resolve when speech ends (with a safe fallback)
        let settled = false;
        const settle = () => { if (!settled){ settled = true; resolve(); } };
        u.onend = settle;
        u.onerror = settle;

        speechSynthesis.cancel(); // stop any prior utterance
        speechSynthesis.speak(u);

        // Fallback in case onend never fires on some browsers
        const approxMs = Math.max(600, text.length * 60 / u.rate); // crude length-based estimate
        setTimeout(settle, approxMs + 200);
      }catch(e){
        console.warn('TTS error', e);
        resolve();
      }
    });
  }


  // ===== Audio unlock + Start/Stop =====
  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audio.init();
    const ctx=audio.ctx;
    const b=ctx.createBuffer(1,1,22050);
    const src=ctx.createBufferSource(); src.buffer=b; src.connect(audio.master);
    try{ src.start(0); }catch(e){}
    ctx.resume().catch(()=>{});
    audioUnlocked=true;
    const btn=document.getElementById('unlockAudio'); if(btn) btn.style.display='none';
  }
  ['touchend','mousedown','keydown'].forEach(ev=>window.addEventListener(ev,unlockAudioOnce,{once:true,passive:true}));

  async function start(){
    audio.init();
    if(audio.ctx.state==='suspended'){ try{ await audio.ctx.resume(); }catch(e){} }
    running=true; startBtn.classList.add('running'); statusEl.textContent='Running…';
    if(wakeLockEnabled) requestWakeLock();
    round=0;

    while(running){
      round++;
      const n=Math.max(1,+cadEvery.value);
      if(((round-1) % n)===0){ await playCadence(); }

      await sleepSec(parseFloat(preSil.value));
      const k=Math.min(4, Math.max(1, parseInt(stackCountEl.value,10) || 1));
      const targets=pickRandomTargets(k);
      if(!targets.length){ statusEl.textContent='No valid notes in range/selection.'; stop(); return; }

      await playTargets(targets);
      await sleepSec(parseFloat(revealWait.value));
      await revealAllSequential(targets);
      await sleepSec(parseFloat(between.value));
    }
  }
  function stop(){ running=false; startBtn.classList.remove('running'); statusEl.textContent='Stopped.'; releaseWakeLock(); }

  // Single (correct) registration – no duplicate consts here.
  startBtn.addEventListener('click',()=>{ if(!running) start(); });
  stopBtn.addEventListener('click',stop);

  revealModeEl.addEventListener('change', () => {
    if (revealModeEl.value === 'speak') { try { tts.init(); } catch(_){} }
  });


})();
</script>
</body>
</html>
