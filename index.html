<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Hands-Free Ear Trainer (Notes + Chords)</title>
<style>
  :root{--bg:#0e0f12;--panel:#171a20;--text:#eaeef5;--muted:#9aa4b2}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
  header{padding:16px 20px;border-bottom:1px solid #1f222b;background:linear-gradient(180deg,#12141a,#0e0f12 60%)}
  h1{margin:0 0 4px;font-size:18px}.sub{margin:0;color:var(--muted);font-size:13px}
  .wrap{max-width:1000px;margin:0 auto;padding:16px;display:grid;gap:16px}
  .panel{background:var(--panel);border:1px solid #252935;border-radius:12px;padding:12px}
  .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
  fieldset{border:1px solid #2a3040;border-radius:10px;padding:10px 12px}
  legend{color:var(--muted);font-size:12px;padding:0 6px}
  label{font-size:13px}
  select,input[type=number]{background:#0f1116;color:#eaeef5;border:1px solid #2a3040;border-radius:8px;padding:6px 8px}
  button{background:#1b2430;color:#eaeef5;border:1px solid #2a3040;border-radius:10px;padding:10px 14px;cursor:pointer;font-weight:600}
  button.running{background:#1f3b2a;border-color:#2d614a;color:#c8ffd7}
  .hint{color:var(--muted);font-size:12px}

  /* Tabs */
  .tabs{display:flex;gap:6px;border-bottom:1px solid #252935;padding:0 4px}
  .tab{padding:8px 12px;border:1px solid #252935;border-bottom:none;border-top-left-radius:10px;border-top-right-radius:10px;background:#13171e;color:#b9c3d1;cursor:pointer}
  .tab.active{background:#1a1f28;color:#eaeef5}
  .tabpanes{border:1px solid #252935;border-radius:12px;padding:0}
  .pane{display:none;padding:12px}
  .pane.active{display:block}

  /* Keyboard */
  .kbd-wrap{display:flex;justify-content:center}
  .keyboard{position:relative;height:178px}
  .white,.black{position:absolute;border:1px solid #333;border-bottom-left-radius:4px;border-bottom-right-radius:4px}
  .white{background:#fff}
  .black{background:#111;border-color:#222;z-index:2}
  .white.lit{box-shadow:inset 0 0 0 2px #0077ff,0 0 12px #0077ff;background:#f2fbff}
  .black.lit{box-shadow:inset 0 0 0 2px #66ccff,0 0 12px #66ccff;background:#1f3b4d}
  .note-tag{position:absolute;left:0;right:0;text-align:center;font-size:11px;color:#333;pointer-events:none}
  .solf-tag{position:absolute;left:0;right:0;text-align:center;font-size:12px;font-weight:700;color:#26323f;pointer-events:none}
  .variant-tag{position:absolute;left:0;right:0;text-align:center;font-size:10px;color:#5e6a77;pointer-events:none}
  .white .note-tag{bottom:42px}.white .solf-tag{bottom:22px}.white .variant-tag{bottom:6px}
  .black .note-tag{bottom:36px;color:#ccd;font-weight:600}.black .solf-tag{bottom:18px;color:#e2eef9}
  .black .variant-tag{bottom:6px;color:#c7d6e6}
  .white.lit .note-tag{color:#014}.black.lit .note-tag{color:#e8f7ff}
  .white.lit .solf-tag{color:#013}.black.lit .solf-tag{color:#e8f7ff}
  .white.lit .variant-tag{color:#012}.black.lit .variant-tag{color:#e8f7ff}

  /* Big overlay */
  .syllable-pop{
    position:fixed; left:50%; top:14%; transform:translateX(-50%);
    font-size:48px; font-weight:800; letter-spacing:1px;
    color:#eaf6ff; text-shadow:0 2px 14px rgba(0,0,0,0.55);
    pointer-events:none; opacity:0; transition:opacity .06s ease;
    background:rgba(20,28,40,0.55); padding:.25rem .75rem; border-radius:12px; border:1px solid #2a3b50;
    z-index:9999;
  }
  .syllable-pop.show{ opacity:1; }

  /* Audio unlock */
  #unlockAudio{
    position:fixed; inset:0; z-index:99999; background:#0e0f12; display:flex;
    align-items:center; justify-content:center; border:0; color:#eaeef5;
    font-size:20px; font-weight:700; letter-spacing:.3px
  }

  @media (max-width:520px){
    button, select, input[type=number]{ padding:12px 14px; font-size:16px }
    .panel{ padding:10px }
  }
</style>
</head>
<body>
<header>
  <h1>Hands-Free Ear Trainer</h1>
  <p class="sub">Train your ears in the background</p>
</header>

<!-- Audio unlock (iOS Safari safe) -->
<button id="unlockAudio">Tap to enable sound</button>

<div class="wrap">
  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" data-pane="notesPane">Notes</button>
    <button class="tab" data-pane="chordsPane">Chords</button>
  </div>
  <div class="tabpanes panel">
    <!-- NOTES PANE -->
    <div id="notesPane" class="pane active">
      <div class="row">
        <fieldset>
          <legend>Pitch-classes (targets)</legend>
          <div class="row" id="pcRow_notes"></div>
          <div class="hint">Tick which of the 12 notes may be chosen as targets.</div>
        </fieldset>

        <fieldset>
          <legend>Range for targets</legend>
          <div class="row">
            <label>Lowest</label><select id="lowSel_notes"></select>
            <label>Highest</label><select id="highSel_notes"></select>
          </div>
          <div class="hint">Only the target(s) are range-filtered; reveal stays in each target’s octave.</div>
        </fieldset>

        <fieldset>
          <legend>Flow</legend>
          <div class="row">
            <label>Cadence every</label><input id="cadEvery_notes" type="number" min="1" value="1" style="width:72px"> rounds
            <label>BPM (cadence)</label><input id="bpm_notes" type="number" min="30" max="200" value="88" style="width:80px">
            <label>Targets at once</label>
            <select id="stackCount_notes"><option>1</option><option>2</option><option>3</option><option>4</option></select>
          </div>
          <div class="row">
            <label>Pre-note silence</label><input id="preSil_notes" type="number" min="0" step="0.1" value="0.5" style="width:80px"> s
            <label>Note→reveal wait</label><input id="revealWait_notes" type="number" min="0" step="0.1" value="1.4" style="width:80px"> s
            <label>Between rounds</label><input id="between_notes" type="number" min="0" step="0.1" value="1.2" style="width:80px"> s
          </div>
        </fieldset>

        <fieldset>
          <legend>Timing</legend>
          <div class="row">
            <label>Note duration (target)</label><input id="noteLen_notes" type="number" min="0.05" step="0.05" value="0.8" style="width:90px"> s
            <label>Reveal tempo</label><input id="revealBpm_notes" type="number" min="30" max="360" value="80" style="width:90px"> BPM
          </div>
          <div class="hint">Reveal notes auto-shortened (~80% of step) so they never overlap.</div>
        </fieldset>

        <fieldset>
          <legend>Reveal Mode</legend>
          <div class="row">
            <label>How to reveal</label>
            <select id="revealMode_notes" style="width:180px">
              <option value="scale">Play scale (current)</option>
              <option value="speak">Speak</option>
            </select>
            <label>
              <input id="speakRef_notes" type="checkbox">
              Mix quiet reference tone (only for simultaneous mode)
            </label>
          </div>
          <div class="row">
            <label>Spoken content</label>
            <select id="speechContent_notes" style="width:180px">
              <option value="note">Note names (C, C sharp…)</option>
              <option value="solfege">Solfège (Doh, Ray…)</option>
            </select>
            <label>
              <input id="speakOctave_notes" type="checkbox" checked>
              Include octave number
            </label>
          </div>
        </fieldset>
      </div>

      <div class="panel" style="margin-top:12px">
        <div class="row">
          <button id="startBtn_notes">Start</button>
          <button id="stopBtn_notes">Stop</button>
          <span id="status_notes" class="hint">Stopped.</span>
        </div>
      </div>

      <div class="panel kbd-wrap">
        <div id="keyboard_notes" class="keyboard" aria-label="Single-octave keyboard"></div>
      </div>
    </div>

    <!-- CHORDS PANE -->
    <div id="chordsPane" class="pane">
      <div class="row">
        <fieldset>
          <legend>Chord roots (12-PC)</legend>
          <div class="row" id="pcRow_chords"></div>
          <div class="hint">Choose which roots can be used for the random chord (includes non-diatonic roots).</div>
        </fieldset>

        <fieldset>
          <legend>Chord qualities</legend>
          <div class="row" id="qualTriads">
            <label><input type="checkbox" class="qual" value="maj" checked> Major</label>
            <label><input type="checkbox" class="qual" value="min" checked> Minor</label>
            <label><input type="checkbox" class="qual" value="dim" checked> Diminished</label>
            <label><input type="checkbox" class="qual" value="aug"> Augmented</label>
          </div>
          <div class="row" id="qual7ths">
            <label><input type="checkbox" class="qual7" value="maj7" checked> maj7</label>
            <label><input type="checkbox" class="qual7" value="min7" checked> min7</label>
            <label><input type="checkbox" class="qual7" value="dom7" checked> 7 (dominant)</label>
            <label><input type="checkbox" class="qual7" value="halfdim7"> ø7 (m7♭5)</label>
            <label><input type="checkbox" class="qual7" value="dim7"> o7 (dim7)</label>
          </div>
          <div class="hint">Select exactly which chord qualities you want the trainer to use (triads and/or sevenths).</div>
        </fieldset>

        <fieldset>
          <legend>Voicing</legend>
          <div class="row">
            <label>Inversions</label>
            <select id="invMode" style="width:160px">
              <option value="root">Root only</option>
              <option value="any" selected>Include inversions</option>
            </select>
          </div>
        </fieldset>

        <fieldset>
          <legend>Cadence & timing</legend>
          <div class="row">
            <label>BPM (cadence)</label><input id="bpm_chords" type="number" min="30" max="200" value="88" style="width:80px">
            <label>Cadence chord length</label>
            <select id="cadBeatLen" style="width:120px">
              <option value="q" selected>Quarter</option>
              <option value="h">Half</option>
            </select>
            <label>Post-cadence rest (beats)</label><input id="postCadBeats" type="number" min="0" step="1" value="1" style="width:70px">
          </div>
          <div class="row">
            <label>Delay before reveal (beats)</label><input id="revealBeats" type="number" min="0" step="0.5" value="2" style="width:80px">
            <label>Chord duration</label><input id="chordDur" type="number" min="0.2" step="0.1" value="1.0" style="width:80px"> s
          </div>
          <div class="hint">Gaps are tied to the cadence BPM so the space “feels” musical.</div>
        </fieldset>
      </div>

      <div class="panel" style="margin-top:12px">
        <div class="row">
          <button id="startBtn_chords">Start</button>
          <button id="stopBtn_chords">Stop</button>
          <span id="status_chords" class="hint">Stopped.</span>
        </div>
      </div>

      <div class="panel kbd-wrap">
        <div id="keyboard_chords" class="keyboard" aria-label="Single-octave keyboard"></div>
      </div>
    </div>
  </div>
</div>

<div id="syllPop" class="syllable-pop"></div>

<script>
(() => {
  // ===== State =====
  let running_notes=false, running_chords=false, audioUnlocked=false;
  let wakeLock=null, wakeLockEnabled=true;

  // ===== Music helpers =====
  const A4=440, A4_MIDI=69;
  const noteNames=["C","C♯","D","D♯","E","F","F♯","G","G♯","A","A♯","B"];
  const diatonicPCs=new Set([0,2,4,5,7,9,11]);
  const midiToFreq=m=>A4*Math.pow(2,(m-A4_MIDI)/12);
  const midiToName=m=>`${noteNames[m%12]}${Math.floor(m/12)-1}`;
  const nearestLocalCDown=m=>Math.floor(m/12)*12;
  const isAccidental=m=>!diatonicPCs.has(m%12);
  const pcToNameText = pc => ["C","C sharp","D","D sharp","E","F","F sharp","G","G sharp","A","A sharp","B"][pc];

  // Kodály syllables (+ phonetic for TTS)
  const DIA = {0:"DO",2:"RE",4:"MI",5:"FA",7:"SOL",9:"LA",11:"TI"};
  const SHP = {1:"DI",3:"RI",6:"FI",8:"SI",10:"LI"};
  const FLT = {1:"RA",3:"ME",6:"SE",8:"LE",10:"TE"};
  function syllableForPC(pc, dir){ if(DIA[pc]) return DIA[pc]; return dir==='down'?FLT[pc]:SHP[pc]; }
  function solfegePhonetic(pc, dir){
    const DIAp={0:"doh",2:"ray",4:"mee",5:"fah",7:"sohl",9:"lah",11:"tee"};
    const SHPp={1:"dee",3:"ree",6:"fee",8:"see",10:"lee"};
    const FLTp={1:"rah",3:"may",6:"say",8:"lay",10:"tay"};
    if (DIAp[pc]) return DIAp[pc];
    return (dir==='down'?FLTp[pc]:SHPp[pc]);
  }

  // ===== Audio =====
  const audio={ctx:null, master:null,
    init(){ if(!this.ctx){ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); this.master=this.ctx.createGain(); this.master.gain.value=0.28; this.master.connect(this.ctx.destination);} },
    t(){ return this.ctx?this.ctx.currentTime:0; }
  };

  // ===== TTS =====
  const tts = {
    ready:false, voices:[],
    init(){ if(this.ready) return;
      const load=()=>{ this.voices=speechSynthesis.getVoices()||[]; this.ready=true; };
      load(); window.speechSynthesis.onvoiceschanged=load;
    },
    pickVoice(){ return this.voices.find(v=>/en(-|_|$)/i.test(v.lang)) || this.voices[0] || null; }
  };
  function speakAsyncText(text,{rate=1.0,volume=1.0}={}){
    return new Promise(res=>{
      try{
        tts.init();
        const u=new SpeechSynthesisUtterance(text);
        const v=tts.pickVoice(); if(v) u.voice=v;
        u.rate=Math.max(0.5,Math.min(1.4,rate)); u.volume=Math.max(0,Math.min(1,volume));
        let done=false; const settle=()=>{ if(!done){done=true;res();} };
        u.onend=settle; u.onerror=settle;
        speechSynthesis.cancel(); speechSynthesis.speak(u);
        const approxMs=Math.max(600, text.length*60/u.rate); setTimeout(settle, approxMs+300);
      }catch(e){ console.warn(e); res(); }
    });
  }

  // ===== UI helpers (shared) =====
  function quarterSec(bpm){ return 60/Math.max(30,+bpm); }

  // ===== Wake Lock =====
  async function requestWakeLock(){
    try{ if('wakeLock' in navigator){
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release',()=>console.log('Wake Lock released'));
    }}catch(err){ console.warn('Wake Lock error',err); }
  }
  function releaseWakeLock(){ if(wakeLock){ wakeLock.release().catch(()=>{}); wakeLock=null; } }
  document.addEventListener('visibilitychange', ()=>{
    if(document.visibilityState==='visible'){
      if(wakeLockEnabled) requestWakeLock();
      if(audio.ctx && audio.ctx.state!=='running'){ audio.ctx.resume().catch(()=>{}); }
    }else{ releaseWakeLock(); }
  });

  // ===== Keyboards (two panes) =====
  function makeKeyboard(kbdEl){
    let WHITE_W, WHITE_H, BLACK_W, BLACK_H;
    const whitePC=[0,2,4,5,7,9,11];
    const blackAfter={0:1,2:3,5:6,7:8,9:10};
    const pcToKeyEl=new Map();

    function size(){
      const maxPx=Math.min(window.innerWidth-32, 560);
      const perWhite=Math.max(28, Math.floor(maxPx/7));
      WHITE_W=perWhite; WHITE_H=Math.round(WHITE_W*4.4);
      BLACK_W=Math.round(WHITE_W*0.66); BLACK_H=Math.round(WHITE_H*0.68);
      kbdEl.style.height=(WHITE_H+20)+'px';
      kbdEl.style.width=(WHITE_W*7 + 2)+'px';
    }
    function enhFlat(pc){ const map={1:'D♭',3:'E♭',6:'G♭',8:'A♭',10:'B♭'}; return map[pc]||''; }
    function draw(){
      kbdEl.innerHTML=''; pcToKeyEl.clear();
      whitePC.forEach((pc,i)=>{
        const x=i*WHITE_W;
        const w=document.createElement('div'); w.className='white';
        Object.assign(w.style,{width:WHITE_W+'px',height:WHITE_H+'px',left:x+'px',top:'0px'});
        const tag=document.createElement('div'); tag.className='note-tag'; tag.textContent=noteNames[pc];
        const solf=document.createElement('div'); solf.className='solf-tag'; solf.textContent=DIA[pc];
        const varTag=document.createElement('div'); varTag.className='variant-tag'; varTag.textContent='';
        w.appendChild(tag); w.appendChild(solf); w.appendChild(varTag);
        kbdEl.appendChild(w); pcToKeyEl.set(pc,w);
      });
      whitePC.forEach((pc,i)=>{
        if(!(pc in blackAfter)) return;
        const bpc=blackAfter[pc];
        const left=i*WHITE_W + (WHITE_W - BLACK_W/2);
        const b=document.createElement('div'); b.className='black';
        Object.assign(b.style,{width:BLACK_W+'px',height:BLACK_H+'px',left:left+'px',top:'0px'});
        const tag=document.createElement('div'); tag.className='note-tag'; tag.textContent=noteNames[bpc].replace('♯','#')+' / '+enhFlat(bpc);
        const solf=document.createElement('div'); solf.className='solf-tag'; solf.textContent='';
        const varTag=document.createElement('div'); varTag.className='variant-tag'; varTag.textContent=`${SHP[bpc]} / ${FLT[bpc]}`;
        b.appendChild(tag); b.appendChild(solf); b.appendChild(varTag);
        kbdEl.appendChild(b); pcToKeyEl.set(bpc,b);
      });
    }
    function lightPC(pc,start,dur){
      const el=pcToKeyEl.get(pc); if(!el) return;
      const now=audio.t();
      const msUntil=Math.max(0,(start-now)*1000), msDur=dur*1000;
      setTimeout(()=>{el.classList.add('lit'); setTimeout(()=>el.classList.remove('lit'),msDur);},msUntil);
    }
    function lightChord(pcs,start,dur){ pcs.forEach(pc=>lightPC(pc,start,dur)); }
    size(); draw(); window.addEventListener('resize',()=>{size(); draw();},{passive:true});
    return {lightPC, lightChord};
  }

  // ===== Synth: gentle additive + optional bass octave-up helper =====
  function scheduleTone(midi, start, dur, vel=0.95){
    const ctx = audio.ctx; const f = midiToFreq(midi);
    const bus = ctx.createGain();
    const A=0.01,D=0.06,S=0.75,R=Math.min(0.12,Math.max(0.06,dur*0.33));
    const peak=vel, sustain=vel*S;
    bus.gain.setValueAtTime(0.0001,start);
    bus.gain.linearRampToValueAtTime(peak,start+A);
    bus.gain.linearRampToValueAtTime(sustain,start+A+D);
    bus.gain.setValueAtTime(sustain,start+Math.max(0,dur-R));
    bus.gain.linearRampToValueAtTime(0.0001,start+dur);

    const o1=ctx.createOscillator(); o1.type='sine'; o1.frequency.value=f; o1.connect(bus);
    const o2=ctx.createOscillator(), g2=ctx.createGain(); o2.type='sine'; o2.frequency.value=f*2; g2.gain.value=0.18; o2.connect(g2); g2.connect(bus);
    const o3=ctx.createOscillator(), g3=ctx.createGain(); o3.type='sine'; o3.frequency.value=f*3; g3.gain.value=0.10; o3.connect(g3); g3.connect(bus);
    let oUp,gUp; if(f<130){ oUp=ctx.createOscillator(); gUp=ctx.createGain(); oUp.type='sine'; oUp.frequency.value=f*2; gUp.gain.value=0.22; oUp.connect(gUp); gUp.connect(bus); }
    bus.connect(audio.master);
    [o1,o2,o3].forEach(o=>o.start(start)); if(oUp) oUp.start(start);
    const stopAt=start+dur+0.05; [o1,o2,o3].forEach(o=>o.stop(stopAt)); if(oUp) oUp.stop(stopAt);
  }
  function scheduleChord(midis,start,dur,vel=0.95){ midis.forEach(m=>scheduleTone(m,start,dur,vel)); }

  // ===== Tabs =====
  const tabs=[...document.querySelectorAll('.tab')];
  const panes=[...document.querySelectorAll('.pane')];
  tabs.forEach(t=>{
    t.addEventListener('click',()=>{
      tabs.forEach(x=>x.classList.remove('active'));
      panes.forEach(x=>x.classList.remove('active'));
      t.classList.add('active'); document.getElementById(t.dataset.pane).classList.add('active');
    });
  });

  // ===== NOTES PANE LOGIC =====
  const pcRow_notes=document.getElementById('pcRow_notes');
  const lowSel_notes=document.getElementById('lowSel_notes');
  const highSel_notes=document.getElementById('highSel_notes');
  const cadEvery_notes=document.getElementById('cadEvery_notes');
  const bpm_notes=document.getElementById('bpm_notes');
  const preSil_notes=document.getElementById('preSil_notes');
  const revealWait_notes=document.getElementById('revealWait_notes');
  const between_notes=document.getElementById('between_notes');
  const noteLen_notes=document.getElementById('noteLen_notes');
  const revealBpm_notes=document.getElementById('revealBpm_notes');
  const stackCount_notes=document.getElementById('stackCount_notes');
  const startBtn_notes=document.getElementById('startBtn_notes');
  const stopBtn_notes=document.getElementById('stopBtn_notes');
  const status_notes=document.getElementById('status_notes');
  const kbd_notes_el=document.getElementById('keyboard_notes');
  const revealMode_notes=document.getElementById('revealMode_notes');
  const speakRef_notes=document.getElementById('speakRef_notes');
  const speechContent_notes=document.getElementById('speechContent_notes');
  const speakOctave_notes=document.getElementById('speakOctave_notes');

  const kbd_notes = makeKeyboard(kbd_notes_el);

  // Build PC toggles (default: ALL SELECTED)
  const pcChecks_notes=[];
  for(let pc=0;pc<12;pc++){
    const wrap=document.createElement('label');
    const cb=document.createElement('input');
    cb.type='checkbox'; cb.value=pc; cb.checked=true; // default all ON
    pcChecks_notes.push(cb); wrap.appendChild(cb); wrap.appendChild(document.createTextNode(' '+noteNames[pc]));
    pcRow_notes.appendChild(wrap);
  }

  // Range options
  const LOW=36,HIGH=96;
  function addOpts(sel,from,to,def){ for(let m=from;m<=to;m++){const o=document.createElement('option');o.value=m;o.textContent=midiToName(m);sel.appendChild(o);} sel.value=def; }
  addOpts(lowSel_notes,LOW,HIGH,48); addOpts(highSel_notes,LOW,HIGH,84);
  [lowSel_notes,highSel_notes].forEach(el=>el.addEventListener('change',()=>{ if(+lowSel_notes.value>+highSel_notes.value) highSel_notes.value=lowSel_notes.value; if(+highSel_notes.value<+lowSel_notes.value) lowSel_notes.value=highSel_notes.value; }));

  // Popup overlay
  const syllPop=document.getElementById('syllPop');
  function showSyllableAt(time,dur,text){
    const msUntil=Math.max(0,(time-audio.t())*1000), msDur=Math.max(150,dur*1000);
    setTimeout(()=>{syllPop.textContent=text; syllPop.classList.add('show'); setTimeout(()=>syllPop.classList.remove('show'),msDur);},msUntil);
  }

  function revealStepSec_notes(){ return 60/Math.max(30,+revealBpm_notes.value); }

  async function playCadence_notes(){
    const q=quarterSec(+bpm_notes.value);
    const dur=(q*(document.getElementById('cadBeatLen')?1:1))*0.9; // notes pane: fixed quarter-ish
    const g=0.9, t=audio.t()+0.02;
    const I=[60,64,67], IV=[65,69,72], V=[67,71,74];
    scheduleChord(I,t,dur,g); scheduleChord(IV,t+q,dur,g); scheduleChord(V,t+2*q,dur,g); scheduleChord(I,t+3*q,dur*1.15,g);
    await new Promise(r=>setTimeout(r,(4*q+0.05)*1000));
  }

  function pickPool_notes(){
    const l=+lowSel_notes.value, h=+highSel_notes.value;
    const allowed=new Set(pcChecks_notes.filter(cb=>cb.checked).map(cb=>+cb.value));
    const pool=[]; for(let m=l;m<=h;m++){ if(allowed.has(m%12)) pool.push(m); }
    return pool;
  }
  function pickTargets_notes(k){
    const pool=pickPool_notes(); if(!pool.length) return [];
    const chosen=[]; const bag=pool.slice();
    while(chosen.length<k && bag.length){
      const idx=Math.floor(Math.random()*bag.length);
      chosen.push(bag[idx]); bag.splice(idx,1);
    }
    return chosen.sort((a,b)=>a-b);
  }

  function buildReveal_Fsplit(midi){
    const localC=nearestLocalCDown(midi), topC=localC+12, pc=midi%12, goUp=(pc>=6);
    const seq=[midi];
    if(goUp){
      let cur=midi; if(isAccidental(cur) && cur+1<=topC){ cur+=1; seq.push(cur); }
      const asc=[7,9,11,12].map(s=>localC+s); for(const n of asc){ if(n>cur && n<=topC) seq.push(n); }
      return {seq, dir:'up'};
    }else{
      let cur=midi; if(isAccidental(cur) && cur-1>=localC){ cur-=1; seq.push(cur); }
      const desc=[5,4,2,0].map(s=>localC+s); for(const n of desc){ if(n<cur && n>=localC) seq.push(n); }
      return {seq, dir:'down'};
    }
  }

  // Speak label builder (notes)
  function buildSpokenLabel_notes(midi, dir, {includeOctave=true, mode='note'}={}){
    const pc=midi%12; const oct=Math.floor(midi/12)-1;
    if(mode==='solfege'){
      const syl=solfegePhonetic(pc,dir);
      return includeOctave?`${syl} ${oct}`:syl;
    }else{
      const base=["C","C sharp","D","D sharp","E","F","F sharp","G","G sharp","A","A sharp","B"][pc];
      return includeOctave?`${base} ${oct}`:base;
    }
  }
  function speakLabelAsync_notes(midi, dir, {includeOctave=true, rate=1.0, volume=1.0, mode='note'}={}){
    return speakAsyncText(buildSpokenLabel_notes(midi,dir,{includeOctave,mode}),{rate,volume});
  }

  async function revealOne_notes(midi){
    const step=revealStepSec_notes(), dur=Math.max(0.05, step*0.8);
    const {seq, dir}=buildReveal_Fsplit(midi);
    for(const m of seq){
      const t=audio.t()+0.02; scheduleTone(m,t,dur,0.95);
      kbd_notes.lightPC(m%12,t,dur);
      showSyllableAt(t,dur,syllableForPC(m%12,dir));
      await new Promise(r=>setTimeout(r, step*1000));
    }
  }
  async function revealOneSpeak_notes(midi){
    const step=revealStepSec_notes();
    const toneDur=Math.max(0.4, step*0.8);
    const {dir}=buildReveal_Fsplit(midi);

    const mode=(speechContent_notes && speechContent_notes.value) || 'note';
    const includeOctave=!!(speakOctave_notes && speakOctave_notes.checked);

    await speakLabelAsync_notes(midi,dir,{includeOctave, rate:1.0, volume:1.0, mode});
    await new Promise(r=>setTimeout(r, 80)); // tiny gap
    const t=audio.t()+0.02;
    scheduleTone(midi,t,toneDur,0.95);
    kbd_notes.lightPC(midi%12,t,toneDur);
    await new Promise(r=>setTimeout(r, (toneDur+0.05)*1000));
  }
  async function revealAllSequential_notes(midis){
    const mode=(revealMode_notes && revealMode_notes.value) || 'scale';
    const ordered=midis.slice().sort((a,b)=>a-b);
    if(mode==='speak'){
      for(const m of ordered){ await revealOneSpeak_notes(m); await new Promise(r=>setTimeout(r,100)); }
    }else{
      for(const m of ordered){ await revealOne_notes(m); await new Promise(r=>setTimeout(r,100)); }
    }
  }

  async function start_notes(){
    audio.init(); if(audio.ctx.state==='suspended'){ try{ await audio.ctx.resume(); }catch(e){} }
    running_notes=true; startBtn_notes.classList.add('running'); status_notes.textContent='Running…';
    if(wakeLockEnabled) requestWakeLock();
    let round=0;

    while(running_notes){
      round++;
      const n=Math.max(1,+cadEvery_notes.value);
      if(((round-1)%n)===0){ await playCadence_notes(); }

      await new Promise(r=>setTimeout(r, parseFloat(preSil_notes.value)*1000));
      const k=Math.min(4, Math.max(1, parseInt(stackCount_notes.value,10)||1));
      const targets=pickTargets_notes(k);
      if(!targets.length){ status_notes.textContent='No valid notes in range/selection.'; stop_notes(); return; }

      const len=parseFloat(noteLen_notes.value);
      const t=audio.t()+0.02; scheduleChord(targets,t,len,1.0);
      targets.forEach(m=>kbd_notes.lightPC(m%12,t,len));
      await new Promise(r=>setTimeout(r, len*900)); // ~0.9

      await new Promise(r=>setTimeout(r, parseFloat(revealWait_notes.value)*1000));
      await revealAllSequential_notes(targets);
      await new Promise(r=>setTimeout(r, parseFloat(between_notes.value)*1000));
    }
  }
  function stop_notes(){ running_notes=false; startBtn_notes.classList.remove('running'); status_notes.textContent='Stopped.'; releaseWakeLock(); }

  startBtn_notes.addEventListener('click',()=>{ if(!running_notes) start_notes(); });
  stopBtn_notes.addEventListener('click',stop_notes);
  revealMode_notes.addEventListener('change',()=>{ if(revealMode_notes.value==='speak'){ try{ tts.init(); }catch(_){} }});

  // ===== CHORDS PANE LOGIC =====
  const pcRow_chords=document.getElementById('pcRow_chords');
  const bpm_chords=document.getElementById('bpm_chords');
  const cadBeatLen=document.getElementById('cadBeatLen');
  const postCadBeats=document.getElementById('postCadBeats');
  const revealBeats=document.getElementById('revealBeats');
  const chordDur=document.getElementById('chordDur');
  const invMode=document.getElementById('invMode');
  const startBtn_chords=document.getElementById('startBtn_chords');
  const stopBtn_chords=document.getElementById('stopBtn_chords');
  const status_chords=document.getElementById('status_chords');
  const kbd_chords_el=document.getElementById('keyboard_chords');
  const kbd_chords = makeKeyboard(kbd_chords_el);

  // Root checkboxes (default ALL ON)
  const pcChecks_chords=[];
  for(let pc=0;pc<12;pc++){
    const wrap=document.createElement('label');
    const cb=document.createElement('input');
    cb.type='checkbox'; cb.value=pc; cb.checked=true;
    pcChecks_chords.push(cb); wrap.appendChild(cb); wrap.appendChild(document.createTextNode(' '+noteNames[pc]));
    pcRow_chords.appendChild(wrap);
  }

  function pickRootPC(){
    const allowed=pcChecks_chords.filter(cb=>cb.checked).map(cb=>+cb.value);
    if(!allowed.length) return null;
    return allowed[Math.floor(Math.random()*allowed.length)];
  }

  function selectedQualities(){
    const triads=[...document.querySelectorAll('#qualTriads .qual')].filter(x=>x.checked).map(x=>x.value);
    const sevenths=[...document.querySelectorAll('#qual7ths .qual7')].filter(x=>x.checked).map(x=>x.value);
    return {triads, sevenths};
  }

  function buildChordIntervals(kind){
    switch(kind){
      case 'maj': return [0,4,7];
      case 'min': return [0,3,7];
      case 'dim': return [0,3,6];
      case 'aug': return [0,4,8];
      case 'maj7': return [0,4,7,11];
      case 'min7': return [0,3,7,10];
      case 'dom7': return [0,4,7,10];
      case 'halfdim7': return [0,3,6,10];
      case 'dim7': return [0,3,6,9];
      default: return [0,4,7];
    }
  }

  function chordKindToSpeech(rootPC, kind){
    const rootName = pcToNameText(rootPC);
    const map={
      maj: `${rootName} major`,
      min: `${rootName} minor`,
      dim: `${rootName} diminished`,
      aug: `${rootName} augmented`,
      maj7: `${rootName} major seven`,
      min7: `${rootName} minor seven`,
      dom7: `${rootName} seven`,
      halfdim7: `${rootName} half diminished seven`,
      dim7: `${rootName} diminished seven`,
    };
    return map[kind] || `${rootName} chord`;
  }

  // NEW: human-friendly inversion name
  function inversionLabel(noteCount, invIdx){
    if(invIdx===0) return 'root position';
    const ord = ['first','second','third','fourth'];
    const which = ord[invIdx-1] || `${invIdx}th`;
    return `${which} inversion`;
  }

  // Modified to return inversion info along with midis
  function buildChordMidis(rootPC, kind){
    const base = 48 + rootPC; // C3=48
    const ints = buildChordIntervals(kind).slice();
    const allowInv = (invMode.value==='any');
    const invCount = (ints.length===3?3:4);
    const invIdx = allowInv ? Math.floor(Math.random()*invCount) : 0;
    for(let i=0;i<invIdx;i++){ const x=ints.shift(); ints.push(x+12); }
    const midis = ints.map(semi => base + semi);
    const invLabel = inversionLabel(ints.length, invIdx);
    return { midis, invIdx, invLabel };
  }

  function lightChordOnKey(kbd, midis, start, dur){
    const pcs = [...new Set(midis.map(m=>m%12))];
    kbd.lightChord(pcs, start, dur);
  }

  async function playCadence_chords(){
    const q=quarterSec(+bpm_chords.value);
    const beatLen = (cadBeatLen.value==='h') ? q*2 : q;
    const dur=beatLen*0.9, g=0.9, t0=audio.t()+0.02;
    const I=[60,64,67], IV=[65,69,72], V=[67,71,74];
    scheduleChord(I,t0,dur,g);
    scheduleChord(IV,t0+beatLen,dur,g);
    scheduleChord(V,t0+2*beatLen,dur,g);
    scheduleChord(I,t0+3*beatLen,dur*1.15,g);
    const total = 4*beatLen;
    await new Promise(r=>setTimeout(r,(total+0.05)*1000));
    const restBeats = Math.max(0, +postCadBeats.value || 0);
    if(restBeats>0){ await new Promise(r=>setTimeout(r, restBeats*q*1000)); }
  }

  async function start_chords(){
    audio.init(); if(audio.ctx.state==='suspended'){ try{ await audio.ctx.resume(); }catch(e){} }
    running_chords=true; startBtn_chords.classList.add('running'); status_chords.textContent='Running…';
    if(wakeLockEnabled) requestWakeLock();

    while(running_chords){
      await playCadence_chords();

      const rootPC = pickRootPC();
      if(rootPC===null){ status_chords.textContent='Select at least one root.'; stop_chords(); return; }

      const {triads,sevenths}=selectedQualities();
      const bag=[...triads,...sevenths];
      if(!bag.length){ status_chords.textContent='Select at least one chord quality.'; stop_chords(); return; }
      const kind = bag[Math.floor(Math.random()*bag.length)];

      const { midis, invLabel } = buildChordMidis(rootPC, kind);
      const nameText = chordKindToSpeech(rootPC, kind);

      const dur = Math.max(0.2, parseFloat(chordDur.value)||1.0);
      const t = audio.t()+0.02;
      scheduleChord(midis, t, dur, 1.0);
      lightChordOnKey(kbd_chords, midis, t, dur);
      await new Promise(r=>setTimeout(r, dur*900));

      const q=quarterSec(+bpm_chords.value);
      const revealWait = Math.max(0, +revealBeats.value || 0) * q;
      if(revealWait>0){ await new Promise(r=>setTimeout(r, revealWait*1000)); }

      // Speak chord name + inversion
      await speakAsyncText(`${nameText}, ${invLabel}`, {rate:1.0, volume:1.0});
      await new Promise(r=>setTimeout(r, 80));

      const t2=audio.t()+0.02;
      scheduleChord(midis, t2, dur, 0.95);
      lightChordOnKey(kbd_chords, midis, t2, dur);
      await new Promise(r=>setTimeout(r, (dur+0.1)*1000));
    }
  }
  function stop_chords(){ running_chords=false; startBtn_chords.classList.remove('running'); status_chords.textContent='Stopped.'; releaseWakeLock(); }

  startBtn_chords.addEventListener('click',()=>{ if(!running_chords) start_chords(); });
  stopBtn_chords.addEventListener('click',stop_chords);

  // ===== Audio unlock =====
  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audio.init();
    const ctx=audio.ctx;
    const b=ctx.createBuffer(1,1,22050);
    const src=ctx.createBufferSource(); src.buffer=b; src.connect(audio.master);
    try{ src.start(0); }catch(e){}
    ctx.resume().catch(()=>{});
    audioUnlocked=true;
    const btn=document.getElementById('unlockAudio'); if(btn) btn.style.display='none';
  }
  ['touchend','mousedown','keydown'].forEach(ev=>window.addEventListener(ev,unlockAudioOnce,{once:true,passive:true}));

})();
</script>
</body>
</html>
